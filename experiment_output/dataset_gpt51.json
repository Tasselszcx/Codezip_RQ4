[
  {
    "id": "ragchatbot-codebase_backend_session_manager.py",
    "repo": "https-deeplearning-ai/ragchatbot-codebase",
    "url": "https://github.com/https-deeplearning-ai/ragchatbot-codebase/blob/main/backend/session_manager.py",
    "code": "from dataclasses import dataclass\nfrom typing import Dict, List, Optional\n\n\n@dataclass\nclass Message:\n    \"\"\"Represents a single message in a conversation\"\"\"\n\n    role: str  # \"user\" or \"assistant\"\n    content: str  # The message content\n\n\nclass SessionManager:\n    \"\"\"Manages conversation sessions and message history\"\"\"\n\n    def __init__(self, max_history: int = 5):\n        self.max_history = max_history\n        self.sessions: Dict[str, List[Message]] = {}\n        self.session_counter = 0\n\n    def create_session(self) -> str:\n        \"\"\"Create a new conversation session\"\"\"\n        self.session_counter += 1\n        session_id = f\"session_{self.session_counter}\"\n        self.sessions[session_id] = []\n        return session_id\n\n    def add_message(self, session_id: str, role: str, content: str):\n        \"\"\"Add a message to the conversation history\"\"\"\n        if session_id not in self.sessions:\n            self.sessions[session_id] = []\n\n        message = Message(role=role, content=content)\n        self.sessions[session_id].append(message)\n\n        # Keep conversation history within limits\n        if len(self.sessions[session_id]) > self.max_history * 2:\n            self.sessions[session_id] = self.sessions[session_id][\n                -self.max_history * 2 :\n            ]\n\n    def add_exchange(self, session_id: str, user_message: str, assistant_message: str):\n        \"\"\"Add a complete question-answer exchange\"\"\"\n        self.add_message(session_id, \"user\", user_message)\n        self.add_message(session_id, \"assistant\", assistant_message)\n\n    def get_conversation_history(self, session_id: Optional[str]) -> Optional[str]:\n        \"\"\"Get formatted conversation history for a session\"\"\"\n        if not session_id or session_id not in self.sessions:\n            return None\n\n        messages = self.sessions[session_id]\n        if not messages:\n            return None\n\n        # Format messages for context\n        formatted_messages = []\n        for msg in messages:\n            formatted_messages.append(f\"{msg.role.title()}: {msg.content}\")\n\n        return \"\\n\".join(formatted_messages)\n\n    def clear_session(self, session_id: str):\n        \"\"\"Clear all messages from a session\"\"\"\n        if session_id in self.sessions:\n            self.sessions[session_id] = []\n",
    "line_count": 66
  },
  {
    "id": "Datarus-JupyterAgent_src_utils_logger.py",
    "repo": "DatarusAI/Datarus-JupyterAgent",
    "url": "https://github.com/DatarusAI/Datarus-JupyterAgent/blob/main/src/utils/logger.py",
    "code": "\"\"\"Console logger for Datarus Pipeline\"\"\"\n\nfrom rich.console import Console\nfrom rich.syntax import Syntax\nfrom rich.panel import Panel\n\n\nclass ConsoleLogger:\n    \"\"\"Enhanced console logger with rich formatting\"\"\"\n    \n    def __init__(self):\n        self.console = Console()\n        self.step_count = 0\n\n    def print(self, *args, **kwargs):\n        \"\"\"Direct console print wrapper\"\"\"\n        self.console.print(*args, **kwargs)\n\n    def print_step(self, title: str, content: str, style: str = \"blue\"):\n        self.step_count += 1\n        self.console.print(f\"[bold {style}]Step {self.step_count}: {title}[/]\")\n        self.console.print(Panel(content, border_style=style))\n\n    def print_code(self, code: str, language: str = \"python\"):\n        syntax = Syntax(code, language, theme=\"monokai\", line_numbers=True)\n        self.console.print(Panel(syntax, border_style=\"green\"))\n\n    def print_error(self, error: str):\n        self.console.print(Panel(error, title=\"âŒ Error\", border_style=\"red\"))\n\n    def print_result(self, result: str):\n        self.console.print(Panel(result, title=\"ðŸ“Š Result\", border_style=\"green\"))\n\n    def print_status(self, message: str, status: str = \"info\"):\n        styles = {\"info\": \"blue\", \"success\": \"green\", \"warning\": \"yellow\", \"error\": \"red\"}\n        style = styles.get(status, \"white\")\n        self.console.print(f\"[{style}]{message}[/]\")\n\n    def print_thought(self, thought: str):\n        self.console.print(Panel(thought, title=\"ðŸ’­ Thought\", border_style=\"cyan\"))\n\n    def print_llm_response(self, response: str):\n        self.console.print(Panel(response, title=\"ðŸ¤– LLM Response\", border_style=\"cyan\"))\n\n    def print_correction(self, message: str):\n        self.console.print(Panel(message, title=\"ðŸ”„ Correction Attempt\", border_style=\"yellow\"))\n    \n    def print_panel(self, content: str, style: str = \"blue\"):\n        \"\"\"Print content in a panel\"\"\"\n        self.console.print(Panel(content, border_style=style))\n",
    "line_count": 50
  },
  {
    "id": "starting-ragchatbot-codebase_backend_session_manager.py",
    "repo": "https-deeplearning-ai/starting-ragchatbot-codebase",
    "url": "https://github.com/https-deeplearning-ai/starting-ragchatbot-codebase/blob/main/backend/session_manager.py",
    "code": "from typing import Dict, List, Optional\nfrom dataclasses import dataclass\n\n@dataclass\nclass Message:\n    \"\"\"Represents a single message in a conversation\"\"\"\n    role: str     # \"user\" or \"assistant\"\n    content: str  # The message content\n\nclass SessionManager:\n    \"\"\"Manages conversation sessions and message history\"\"\"\n    \n    def __init__(self, max_history: int = 5):\n        self.max_history = max_history\n        self.sessions: Dict[str, List[Message]] = {}\n        self.session_counter = 0\n    \n    def create_session(self) -> str:\n        \"\"\"Create a new conversation session\"\"\"\n        self.session_counter += 1\n        session_id = f\"session_{self.session_counter}\"\n        self.sessions[session_id] = []\n        return session_id\n    \n    def add_message(self, session_id: str, role: str, content: str):\n        \"\"\"Add a message to the conversation history\"\"\"\n        if session_id not in self.sessions:\n            self.sessions[session_id] = []\n        \n        message = Message(role=role, content=content)\n        self.sessions[session_id].append(message)\n        \n        # Keep conversation history within limits\n        if len(self.sessions[session_id]) > self.max_history * 2:\n            self.sessions[session_id] = self.sessions[session_id][-self.max_history * 2:]\n    \n    def add_exchange(self, session_id: str, user_message: str, assistant_message: str):\n        \"\"\"Add a complete question-answer exchange\"\"\"\n        self.add_message(session_id, \"user\", user_message)\n        self.add_message(session_id, \"assistant\", assistant_message)\n    \n    def get_conversation_history(self, session_id: Optional[str]) -> Optional[str]:\n        \"\"\"Get formatted conversation history for a session\"\"\"\n        if not session_id or session_id not in self.sessions:\n            return None\n        \n        messages = self.sessions[session_id]\n        if not messages:\n            return None\n        \n        # Format messages for context\n        formatted_messages = []\n        for msg in messages:\n            formatted_messages.append(f\"{msg.role.title()}: {msg.content}\")\n        \n        return \"\\n\".join(formatted_messages)\n    \n    def clear_session(self, session_id: str):\n        \"\"\"Clear all messages from a session\"\"\"\n        if session_id in self.sessions:\n            self.sessions[session_id] = []",
    "line_count": 61
  },
  {
    "id": "physical_atari_agent_random.py",
    "repo": "Keen-Technologies/physical_atari",
    "url": "https://github.com/Keen-Technologies/physical_atari/blob/main/agent_random.py",
    "code": "# Copyright 2025 Keen Technologies, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# agent_random.py\n#\n# Use the last evaluations for target calculation instead of a target model evaluation\nimport time\n\nimport numpy as np\n\nfrom framework.Logger import logger\n\n\nclass Agent:\n    def __init__(self, data_dir, seed, num_actions, total_frames, **kwargs):\n        # defaults that might be overridden by explicit experiment runs\n\n        self.num_actions = num_actions  # many games can use a reduced action set for faster learning\n        self.gpu = -1\n        self.total_frames = total_frames\n        self.frame_skip = 4\n        self.seed = seed\n        self.training_model = None\n        self.ring_buffer_size = 0\n        self.train_losses = 0\n        self.use_model = 0\n\n        # dynamically override configuration\n        for key, value in kwargs.items():\n            try:\n                assert hasattr(self, key)\n            except AssertionError:\n                logger.error(f\"agent_random: Request to set unknown property: {key}\")\n                continue\n            setattr(self, key, value)\n\n        # variables used by policy\n        self.step = 0\n        self.rng = np.random.default_rng(self.seed)\n        self.selected_action_index = 0\n\n    # --------------------------------\n    # Returns the selected action index\n    # --------------------------------\n    def frame(self, observation_rgb8, reward, end_of_episode):\n        if 0 == self.step % self.frame_skip:\n            self.selected_action_index = self.rng.integers(self.num_actions)\n        self.step += 1\n        return self.selected_action_index\n\n    def save_model(self, filename):\n        pass\n",
    "line_count": 63
  },
  {
    "id": "Story2Board_attention_store.py",
    "repo": "DavidDinkevich/Story2Board",
    "url": "https://github.com/DavidDinkevich/Story2Board/blob/main/attention_store.py",
    "code": "import torch\nfrom einops import pack, reduce\n\nclass AttentionStore:\n    def __init__(self, batch_size, n_diff_steps, n_trans_blocks, n_image_tokens, n_attn_heads, dtype, device):\n        self.n_diff_steps = n_diff_steps\n        self.n_trans_blocks = n_trans_blocks\n        self.n_image_tokens = n_image_tokens\n        self.n_attn_heads = n_attn_heads\n        self.concept_token_indices = range(self.n_image_tokens)\n        self.curr_iter = -1\n        self.internal_device = device\n\n        self.attn_map_shape = (batch_size, self.n_image_tokens, self.n_image_tokens // 2)\n\n        self.avg_attn_map = torch.zeros(self.attn_map_shape, device=self.internal_device, dtype=dtype)\n\n        self.curr_diff_step_maps = []\n        self.attn_map_decay = 0.8\n        # self.attn_map_decay = 0.95\n        # self.attn_map_decay = 0.999\n\n    def increment(self):\n        self.curr_iter += 1\n\n    def _get_curr_diffusion_step(self):\n        return self.curr_iter // self.n_trans_blocks\n\n    def _is_first_layer(self):\n        return self.curr_iter % self.n_trans_blocks == 0\n\n    def _is_last_block(self):\n        return self.curr_iter % self.n_trans_blocks == self.n_trans_blocks - 1\n\n    def _get_curr_trans_block(self):\n        return self.curr_iter % self.n_trans_blocks\n    \n    def store_attention_map(self, attn_map):\n        assert attn_map.shape == self.attn_map_shape, \\\n            \"Attention map dimensions are incorrect\"\n\n        attn_map = attn_map.to(device=self.internal_device)\n        self.curr_diff_step_maps.append(attn_map)\n\n        if self._is_last_block():\n            step_avg_attn_map, _ = pack(self.curr_diff_step_maps, 'c * v_toks v_toks2')\n            step_avg_attn_map = reduce(step_avg_attn_map, 'channel layer v_toks v_toks2 -> channel v_toks v_toks2', 'mean')\n\n            curr_step = self._get_curr_diffusion_step()\n            self.curr_diff_step_maps = []\n\n            new_observation = step_avg_attn_map - self.avg_attn_map\n            self.avg_attn_map = (self.attn_map_decay * self.avg_attn_map\n                                       + (1 - self.attn_map_decay) * new_observation / (curr_step + 1))\n\n    def aggregate_attn_maps(self):\n        return self.avg_attn_map\n",
    "line_count": 57
  }
]